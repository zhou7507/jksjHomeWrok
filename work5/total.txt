1.限流：

    1.1在服务端使用限流算法：
    1.1.1固定窗口计数法
        将一段时间划分为多个时间窗口，在每个窗口内进行请求时会进行请求数+1计数，当请求数超出限制时，其余的请求会被丢失，当一个窗口时间结束时，将当前请求数置为0。
    1.1.2 滑动窗口计数法
         将一个时间窗口划分成一个一个的小区间，在每一个区间内对请求数进行统计，然后进行加和，这种算法避免了固定窗口计数器带来的双倍突发请求，当新的窗口区间到来时就抛弃最老的一个区间，如果想要提高精度就需要将单位时间窗口内区间划分的越多。
    1.1.3 漏桶算法
        将请求当成水滴，滴入桶中；桶按照固定的速率漏出水滴进行请求处理；如果水滴滴入的速率大于漏出的速率，那么桶就有可能装满，桶满后多余的请求会被直接丢弃。漏桶算法大多用有界队列实现，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。
    1.1.4 令牌桶算法
        以固定的速率生成令牌放入桶中，每一个请求到来都需要从桶中获取令牌，获取成功则可以进行执行，否则则被丢弃；如果桶中的令牌满了，那么多余令牌会被直接丢弃；如果桶空了请求也会被直接丢弃。
    1.2 使用nginx 限流
    1.2.1 控制速率
    使用 limit_req_zone 用来限制单位时间内的请求数。
    1.2.2 控制并发数
    利用 limit_conn_zone 和 limit_conn 两个指令即可控制并发数


2.熔断

   请求失败率达到指定百分比后拒绝请求

   访问超时，拒绝大多数超时请求，仅开放少量进行尝试

   访问异常数达到一定数量的时候触发异常。

   一些秒杀场景，或者知道服务不可用的时候直接选择熔断，拒绝服务访问


3.降级
    延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。
    在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区
    页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
    页面跳转（页面降级）：跳转到某一个指定地址
    写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。
    读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存

4.重试
    4.1重试策略
    指定重试的间隔，失败后等待间隔时间，进行重试操作。
    指定重试的间隔和上限等待时间，失败后等待间隔时间，进行重试操作，达到上线等待时间后，不再进行重试
    4.2 异步重试
    接收到重试请求后，先根据重试策略获得重试的下一次调度时间以及判断是否应该进行重试，如果不需要重试则直接返回，否则将重试持久化，并写入到延迟队列，到期设置为下一次调度时间。
    处理重试时，可以批量从延迟队列中获取到期的重试请求，取的一个重试请求后，判断重试次数是否超过最大上限，如果超过则从调度表中删除该重试并返回，否则将重试次数加1，更新到数据库中，接下来把重试通知写入到消息队列，回调给使用方，若发送失败，则直接跳过该请求，下一次处理时继续进行重试，发送成功后，继续获取重试下一个周期的调度时间，更新到延迟队列。
    当接收到使用方的重试回应时，删除延迟队列中的重试请求

5.负载均衡
    DNS 轮询
    nginx 反向代理
    lvs/F5+keepalived